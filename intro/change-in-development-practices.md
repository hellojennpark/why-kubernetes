---
description: 모놀리식에서 마이크로서비스까지
---

# 개발 방식의 변화

#### 1. 전통적 개발 방식: 모놀리식 아키텍처의 한계

**1. 모놀리식 아키텍처란?**

<p align="center"><img src="../.gitbook/assets/unknown (1).png" alt=""></p>

과거 대부분의 소프트웨어 애플리케이션은 모놀리식(Monolithic), 즉 '하나의 거대한 덩어리' 형태로 개발되고 배포되었습니다. 이는 애플리케이션의 모든 기능(예: 사용자 관리, 주문/결제, 상품 목록, 재고 관리 등)이 하나의 실행 단위로 묶여 있는 구조를 의미합니다.

초기에는 코드가 단순하고 규모가 작아 개발 및 배포가 간편하다는 장점이 있었지만, 애플리케이션의 규모가 커지고 기능이 복잡해지면서 다음과 같은 심각한 문제들을 야기하기 시작했습니다.

| 문제점             | 왜 문제가 되는가 / 파생 효과                                                                                           |
| --------------- | ----------------------------------------------------------------------------------------------------------- |
| 큰 배포 단위 및 느린 주기 | 작은 기능 수정에도 전체 코드를 다시 빌드(Build), 테스트, 배포해야 합니다. 이로 인해 배포 주기가 길어지고, 새로운 기능이 고객에게 전달되는 속도가 느려집니다.              |
| 어려운 롤백과 버전 관리   | 전체가 하나로 묶여 있어 배포 실패 시 특정 기능만 이전 버전으로 되돌리는 것이 거의 불가능합니다. 데이터베이스 스키마까지 변경된 경우 롤백은 엄청난 위험을 수반합니다.              |
| 단일 오류 지점        | 하나의 모듈에서 발생한 치명적인 오류나 메모리 누수 등이 전체 애플리케이션에 영향을 미쳐 전체 서비스 다운으로 이어질 수 있습니다 (단일 장애점, Single Point of Failure). |
| 비효율적인 리소스 사용    | 특정 기능(예: 결제)에만 부하가 몰려도 전체 애플리케이션 인스턴스를 늘려야 합니다. 이는 부하가 없는 다른 기능 영역의 리소스까지 불필요하게 증설하게 만들어 운영 비용이 비효율적입니다.    |
| 개발 속도 저하 및 충돌   | 여러 개발 팀이 하나의 거대한 코드베이스에서 작업하다 보니, 라이브러리 버전 충돌이나 코드 병합(Merge) 문제가 빈번하게 발생하여 개발 속도가 현저히 늦어집니다.                |

이러한 모놀리식 아키텍처의 제약은 곧 배포 속도 저하, 운영 비용 증가, 그리고 장애 발생 리스크 확대로 이어졌습니다.

#### 2. 마이크로서비스 아키텍처(MSA)의 부상 

<p align="center"><img src="../.gitbook/assets/unknown (2).png" alt=""></p>

\
\


**1. 마이크로서비스란?**

모놀리식의 한계를 극복하고 현대의 민첩한 개발 환경(Agile, DevOps)에 맞추기 위해 등장한 것이 바로 마이크로서비스 아키텍처(MSA, Microservices Architecture)입니다.

MSA는 하나의 거대한 애플리케이션을 독립적인 작은 서비스들의 집합으로 쪼갠 구조입니다. 각 서비스는 특정 비즈니스 기능(예: '주문 서비스', '재고 서비스', '고객 서비스')만을 담당하며, 자체적으로 데이터베이스를 가지고 개발, 배포, 운영될 수 있습니다.

**2. 마이크로서비스의 주요 장점**

마이크로서비스는 민첩성과 확장성 면에서 모놀리식 대비 다음과 같은 장점을 제공합니다.

| 장점                      | 설명                                                                                           |
| ----------------------- | -------------------------------------------------------------------------------------------- |
| 독립적인 개발 및 배포            | 서비스별로 팀을 구성하여 독립적으로 개발하고 배포합니다. 특정 서비스만 빠르게 수정하고 배포(Hotfix)할 수 있어 배포 주기가 극도로 단축됩니다.          |
| 기술 스택의 다양성              | 각 서비스는 서로 다른 프로그래밍 언어나 프레임워크를 사용할 수 있습니다. 서비스의 특성에 가장 적합한 기술을 선택하여 성능을 최적화할 수 있습니다.          |
| 장애 격리 (Fault Isolation) | 한 서비스(예: 재고 서비스)에서 장애가 발생하더라도, 다른 서비스(예: 결제 서비스)에는 영향을 주지 않고 계속 작동합니다. 이는 전체 서비스의 안정성을 높입니다. |
| 수평 확장(Scale-Out) 용이성    | 부하가 높은 특정 서비스만 선택적으로 인스턴스를 늘려(수평 확장) 리소스를 효율적으로 사용할 수 있습니다.                                  |

> **수직 확장 vs. 수평 확장**
>
> * **수직 확장 (Scale-Up):** 기존 서버의 CPU, 메모리 등의 자원을 늘려 성능을 키우는 방식. 한계가 명확하고 고비용입니다.
> * **수평 확장 (Scale-Out):** 동일한 스펙의 인스턴스(서버)를 여러 대 추가하여 부하를 분산하는 방식. 마이크로서비스는 이 수평 확장에 가장 적합하며, 쿠버네티스(Kubernetes)와 같은 컨테이너 오케스트레이션 도구는 이를 자동화합니다.

**3. 마이크로서비스의 복잡성**

마이크로서비스는 강력한 유연성을 제공하지만, 그 대가로 관리 복잡성이 기하급수적으로 증가합니다.

서비스가 수십 개, 수백 개로 늘어나면 다음과 같은 문제를 해결해야 합니다.

1. 서비스 간 통신: 수많은 서비스들이 어떻게 효율적이고 안정적으로 서로 데이터를 주고받을지 관리해야 합니다 (API Gateway, 메시지 큐 등).
2. 분산 트랜잭션: 여러 서비스에 걸쳐 발생하는 작업을 일관성 있게 처리해야 합니다.
3. 관찰 가능성(Observability): 수많은 서비스의 로그, 메트릭, 분산 추적 정보를 수집하고 분석하여 문제 발생 시 원인을 빠르게 파악해야 합니다.
4. 배포 및 리소스 관리: 수많은 서비스를 안정적으로 배포(롤링 업데이트, A/B 테스트 등)하고 관리하기 위해 쿠버네티스와 같은 오케스트레이션 도구가 필수적입니다.

결국 마이크로서비스는 '단순함'을 포기하는 대신 '민첩성과 확장성'을 얻는 구조적 변화입니다.

### 4. 마이크로서비스 시대의 복잡성 해결: 컨테이너 오케스트레이션

#### 1. 오케스트레이션이란 무엇인가?

우리가 앞서 마이크로서비스 아키텍처(MSA)를 통해 민첩성과 확장성을 얻었지만, 이는 동시에 수십, 수백 개의 독립적인 서비스와 컨테이너를 관리해야 하는 운영 복잡성을 낳았습니다.

여기서 등장하는 개념이 바로 오케스트레이션(Orchestration)입니다.

오케스트레이션은 원래 '관현악단 지휘'라는 뜻입니다. 오케스트라 지휘자가 수많은 악기(각 마이크로서비스 컨테이너)들을 조율하여 하나의 완벽한 음악(전체 애플리케이션 서비스)을 연주하게 만들듯이, IT 분야에서의 오케스트레이션은 복잡하게 분산된 수많은 컨테이너와 리소스를 자동화된 방식으로 조율하고 관리하는 시스템을 의미합니다.

즉, 개발자가 "이 컨테이너를 띄워줘"라고 명령하면, 오케스트레이션 도구가 알아서 가장 효율적인 서버에 배치하고, 문제가 생기면 자동으로 고치는 등 모든 운영 작업을 대신 처리하는 것입니다.



#### 2. 컨테이너 오케스트레이션의 핵심 과제

<p align="center"><img src="../.gitbook/assets/unknown (3).png" alt=""></p>

<p align="center">[예시] 오케스트레이션의 핵심 과제 중 하나인 자가복구(Self-Healing)</p>



컨테이너의 수가 많아질수록 사람의 힘으로 수동 관리하는 것은 불가능해집니다. 오케스트레이션 플랫폼이 해결해야 하는 핵심 과제들은 다음과 같습니다.

| 과제 (문제)              | 설명 (해결 방안)                                                                                                            |
| -------------------- | --------------------------------------------------------------------------------------------------------------------- |
| 리소스 스케줄링             | 수백 개의 컨테이너가 요구하는 CPU와 메모리 등의 자원을 계산하여, 가장 효율적인 서버(노드)에 컨테이너를 적절히 배치합니다.                                               |
| 서비스 디스커버리 & 로드밸런싱    | 컨테이너는 동적으로 생성되고 파괴됩니다. 오케스트레이션 도구는 새로 생긴 컨테이너의 위치를 자동으로 찾아내고, 들어오는 사용자 트래픽을 컨테이너들에 균등하게 분산시켜 과부하를 방지합니다.              |
| 배포 전략 및 무중단 업데이트     | 서비스 중단 없이 새로운 버전의 소프트웨어를 배포하기 위해 롤링 업데이트 (트래픽을 서서히 새 버전으로 전환), 블루/그린 배포 (구 버전과 신 버전을 동시에 운영하며 전환) 등의 고급 배포 전략을 구현합니다. |
| 자가 복구 (Self-Healing) | 컨테이너에 오류가 발생하거나 서버가 다운되면, 이를 자동으로 감지하고 해당 컨테이너를 종료한 후 새로운 위치에 재시작하거나 교체하여 서비스의 연속성을 보장합니다.                            |
| 상태 저장 서비스 관리         | 데이터베이스나 캐시처럼 \*\*상태(데이터)\*\*를 유지해야 하는 서비스의 데이터를 안전하게 관리하고, 컨테이너가 재배치되더라도 데이터의 영속성이 보장되도록 지원합니다.                       |
| 네트워크 정책 제어           | 수많은 서비스들이 통신하는 환경에서, '주문 서비스는 재고 서비스와만 통신 가능해야 한다'와 같은 보안 및 접근 제어 정책을 정의하고 적용합니다.                                     |
| 모니터링 (로그/메트릭/트레이싱)   | 분산된 서비스 전체에서 발생하는 로그, 성능 지표(메트릭), 트랜잭션 추적 정보를 중앙에서 효율적으로 수집하여, 운영자가 시스템 상태를 파악하고 장애 원인을 추적할 수 있도록 돕습니다.               |



#### 3. 대표적인 오케스트레이션 도구: 쿠버네티스  

<p align="center"><img src="../.gitbook/assets/unknown (4).png" alt=""></p>

\


이 모든 복잡한 과제를 해결하기 위한 사실상의 표준(De Facto Standard) 플랫폼이 바로 쿠버네티스(Kubernetes)입니다. 쿠버네티스는 컨테이너 오케스트레이션 기능을 제공하는 가장 널리 사용되는 오픈소스 시스템이며, 마이크로서비스 운영의 핵심 인프라로 자리 잡았습니다.

\
