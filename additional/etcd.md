---
description: etcd 에서 읽기/쓰기 작업 시의 내부 통신 흐름을 알아봅시다.
---

# etcd 읽고 쓰기

## etcd 읽기

<figure><img src="../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

etcd는 두 가지 유형의 읽기를 지원합니다:

* **선형화 가능 읽기 (Linearizable Read)**:  **가장 강력한 일관성**을 제공하며, 클라이언트가 항상 **가장 최근에 커밋된 데이터**를 읽도록 보장합니다. 이를 위해 Raft 프로토콜을 통해 Leader의 상태를 검증하는 과정(Read Index)이 필요합니다.
* **직렬화 가능 읽기 (Serializable Read)**: **성능을 최적화**하기 위해 Raft 합의 과정을 생략합니다. 요청받은 개별 etcd 노드가 알고 있는 로컬 상태를 즉시 반환하며, 이는 **Stale Data (오래된 데이터)**&#xC77C; 가능성이 있습니다.

즉, Raft 합의 유무로 구분된다고 보면 되는데요, 클라이언트에서 요청이 들어왔을 때 공통적으로 거치는 검증 과정에 대해 설명하고 각 읽기 유형에 대해 상세히 알아보겠습니다.&#x20;

#### 클라이언트 요청 검증

요청이 들어왔을 때 흐름은 아래와 같습니다.

1. **클라이언트 요청 도착:** `etcd Server` 프로세스의 `API Server` 포트(기본 2379)로 요청이 들어옵니다.
2. **속도 제한 확인:** `API Server`는 요청을 받자마자 내부의 **Client Rate Limiter** 로직을 통과시킵니다.
3. **인증/인가 확인:** Rate Limit을 통과하면, `API Server`는 요청의 보안 정보(인증 헤더 등)를 추출하여 Auth Module에 전달합니다. **Auth** Module은 etcd Store를 참조하여 사용자 권한을 검증합니다.
4. **핵심 로직으로 전달:** 모든 검증을 통과해야 비로소 요청은 Raft Protocol로 전달되어 쓰기 작업을 시작하거나, \*\*Store (MVCC)\*\*에서 읽기 작업을 수행하게 됩니다.

{% hint style="info" %}
**Lease 체크**는 API Server가 직접 처리하는 **Auth단계의 일부**(Lease 자원에 대한 권한 확인)이거나, KV Store가 데이터를 다루기 직전에 수행하는 데이터 유효성 검사에 포함된다고 이해하시면 됩니다.&#x20;
{% endhint %}

| 검증 항목               | etcd 컴포넌트               | 필요성 (목적)                 | 상세 기능 (효과)                                                                                                                                                                                    |
| ------------------- | ----------------------- | ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Client Rate Limiter | API Server              | 안정성 (Stability) & DoS 방어 | 클라이언트의 초당 요청 횟수를 제한하여 특정 클라이언트가 etcd 서버에 과부하를 주어 서비스 거부(DoS) 상태를 유발하는 것을 방지하고, 클러스터의 처리 능력을 보호합니다.                                                                                            |
| AUTH (인증/인가)        | Auth Module             | 보안 (Security) & 데이터 보호   | <ol><li> 인증: 유효한 사용자만 etcd에 접근하도록 통제합니다. </li></ol><ol start="2"><li> 인가: 접근이 허가된 사용자라도, 각 키에 대해 설정된 권한(읽기/쓰기/삭제)을 넘어선 작업을 수행하는 것을 막아 민감한 데이터를 보호합니다.</li></ol>                               |
| LEASE (임대)          | Lease Module & KV Store | 효율성 (Efficiency) & 자원 관리 | <ol><li>클라이언트 연결이 끊어지거나 서비스에 장애가 발생했을 때, 해당 서비스가 등록한 키(예: 분산 락, 서비스 IP)가 만료되어 자동으로 삭제되도록 보장합니다. </li></ol><ol start="2"><li>불필요한 데이터가 영구히 남는 것을 막아 데이터베이스 크기를 관리하고 Deadlock을 방지합니다.</li></ol> |

### 선형화 가능 읽기 (Linearizable Read)

| 단계                   | 요청 주체         | 대상 컴포넌트         | 역할 및 설명                                                                                                                              |
| -------------------- | ------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| \[1] 요청 수신 및 \[2] 검증 | Client        | API Server      | 클라이언트 요청(`GET`)을 수신하고, Auth/Lease 컴포넌트를 통해 인증 및 권한을 확인합니다.                                                                           |
| \[3-1] Raft 리더십 검증   | API Server    | Raft Protocol   | `API Server`는 `Raft Protocol`에게 **Read Index** 요청을 보냅니다. 이는 현재 노드가 여전히 유효한 Leader이며, 자신이 알고 있는 데이터가 클러스터에서 최신 상태임을 보장하기 위한 합의 검증입니다. |
| \[3-2] 인덱스 검증        | Raft Protocol | Raft 노드들        | `Leader`는 `Follower`들에게 **Heartbeat**를 보내 자신의 Term과 **Index**를 확인하고, 과반수로부터 유효함을 응답받습니다. (데이터 복제는 발생하지 않으며, 상태 검증만 이루어집니다.)          |
| \[4] 데이터 인출          | API Server    | KV Store (MVCC) | `Raft Protocol`로부터 검증 완료 응답을 받으면, `API Server`는 KV Store의 인메모리 인덱스에서 요청된 키의 최신 값을 안전하게 가져옵니다.                                        |
| \[5] 응답 전송           | API Server    | 클라이언트           | 클라이언트에게 응답을 반환합니다.                                                                                                                   |

#### Leader 검증

선형화 가능 읽기는 최신 데이터의 일관성을 위해 Leader의 검증이 필요합니다.

| 요청 받은 노드              | 동작                                                                                                                                 |
| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| **리더(Leader)인 경우**    | Raft Protocol의 **Read Index** 메커니즘을 사용하여 자신의 상태가 최신임을 검증합니다. 이 검증이 완료된 후에만 KV Store에서 데이터를 읽어옵니다.                                  |
| **팔로워(Follower)인 경우** | 클라이언트의 요청을 **Leader에게 라우팅(Forwarding)**&#xD569;니다. Leader는 Read Index 검증을 거친 후 응답을 Follower에게 돌려주고, Follower가 최종적으로 클라이언트에게 응답합니다. |

API Server의 **Raft 리더십 검증** 단계는 크게 두 가지를 의미합니다.

1. **클라이언트의 라우팅**: 클라이언트가 팔로워에게 요청을 보내면, 팔로워는 그 요청을 Leader에게 자동으로 라우팅합니다. (쓰기와 선형화 읽기 모두)
2. **Leader의 검증**: Leader는 데이터를 읽기 전에 Read Index를 사용하여 자신이 여전히 Leader이며 최신 데이터를 가지고 있는지 확인합니다.

따라서 클라이언트는 Leader가 누구인지 몰라도 되며, etcd Server 내부의 Raft 컴포넌트가 모든 일관성 및 라우팅 로직을 처리해 줍니다.



#### Read Index

Read Index는 etcd의 Raft 프로토콜 내부에서 **선형화 가능 읽기(Linearizable Read)의 일관성을 보장하기 위해 사용하는 메커니즘이**며, 이 메커니즘을 구현하는 과정에 **Heartbeat 메시지 전송**이 포함됩니다.&#x20;

| 개념         | 역할                                                                                                                                      | Heartbeat 포함 여부                                  |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| Read Index | **Linearizable Read**를 처리하기 위한 총체적인 일관성 검증 메커니즘입니다. **Leader**가 자신이 아직 **Leader**며, 읽으려는 데이터의 **Commit Index**가 유효함을 확인하는 과정 전체를 의미합니다. | Read Index를 구현하는 핵심 단계로 Heartbeat 메시지 전송을 사용합니다. |
| Heartbeat  | $$Raft$$ 노드 간에 정기적으로 전송되는 작은 메시지입니다. 주로 Leader의 생존을 알리고 Follower들이 Candidate로 전환하는 것을 막는 역할을 합니다. Read Index 과정에서는 상태 검증용으로 활용됩니다.      | Read Index 메커니즘을 작동시키는 특정 RPC(함수 호출)의 일종입니다.     |

Leader가 클라이언트로부터 **Linearizable Read** 요청을 받으면, **Read Index** 기능은 다음과 같은 순서로 실행됩니다.

1. 현재 **Commit Index** 기록: Leader는 자신이 알고 있는 가장 최신의 **커밋된 로그 인덱스(Commit Index)**&#xB97C; 로컬에 기록합니다. (이 인덱스 이하의 데이터만 안전하게 읽을 수 있음)
2. **Heartbeat** 전송 (활용): Leader는 모든 Follower에게 **Heartbeat메시지를 강제로 전송**하고 응답을 기다립니다.
3. **Quorum** 확인:Leader는 **과반수(Quorum)**&#xC758; Follower들로부터 Heartbeat 응답을 받으면, 현재 클러스터가 네트워크 분할(Split-Brain) 상태가 아니며 자신이 여전히 **유효한 Leader**임을 확인합니다.
4. 로컬 데이터 읽기: 검증이 완료되면, Leader는 로컬 KV Store에서 1단계에서 기록한 Commit Index까지 반영된 데이터를 읽어서 클라이언트에게 반환합니다.

이 전체 과정을 **Read Index** 메커니즘이라고 부르며, **Heartbeat** 메시지 전송은 Leader의 유효성을 빠르게 확인하기 위한 수단으로 사용되는 것입니다. 쓰기처럼 데이터 복제 과정은 생략하여 성능을 높이면서도 일관성을 유지합니다.



### 직렬화 가능 읽기(Serializable Read)

| 단계                   | 요청 주체      | 대상 컴포넌트         | 역할 및 설명                                                                               |
| -------------------- | ---------- | --------------- | ------------------------------------------------------------------------------------- |
| \[1] 요청 수신 및 \[2] 검증 | Client     | API Server      | 클라이언트 요청(`GET` with `Serializable` 옵션)을 수신하고, Auth/Lease 컴포넌트를 통해 인증 및 권한을 확인합니다.     |
| \[3] Raft 우회 결정      | API Server | -               | 직렬화 가능 읽기 요청이므로, Raft Protocol을 통한 합의나 검증 과정을 완전히 생략합니다.                              |
| \[4] 데이터 인출          | API Server | KV Store (MVCC) | `API Server`는 KV Store의 인메모리 인덱스에서 요청된 키의 로컬 상태 값을 즉시 가져옵니다.                          |
| \[5] 응답 전송           | API Server | 클라이언트           | 클라이언트에게 응답을 반환합니다. 이 데이터는 다른 노드에 최신 Write가 이미 커밋되었더라도 해당 노드의 상태를 반영하므로 최신이 아닐 수 있습니다. |
