---
description: etcd 에서 읽기 작업 시의 내부 통신 흐름을 알아봅시다.
---

# etcd 읽기

## etcd 읽기

<figure><img src="../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

etcd는 두 가지 유형의 읽기를 지원합니다:

* **선형화 가능 읽기 (Linearizable Read)**:  **가장 강력한 일관성**을 제공하며, 클라이언트가 항상 **가장 최근에 커밋된 데이터**를 읽도록 보장합니다. 이를 위해 Raft 프로토콜을 통해 Leader의 상태를 검증하는 과정(Read Index)이 필요합니다.
* **직렬화 가능 읽기 (Serializable Read)**: **성능을 최적화**하기 위해 Raft 합의 과정을 생략합니다. 요청받은 개별 etcd 노드가 알고 있는 로컬 상태를 즉시 반환하며, 이는 **Stale Data (오래된 데이터)**&#xC77C; 가능성이 있습니다.

즉, Raft 합의 유무로 구분된다고 보면 됩니다. 우선 클라이언트에서 요청이 들어왔을 때 공통적으로 거치는 검증 과정과 KV Store(MVCC)에대해 알아보겠습니다.

#### 클라이언트 요청 검증

요청이 들어왔을 때 흐름은 아래와 같습니다.

1. **클라이언트 요청 도착:** `etcd Server` 프로세스의 `API Server` 포트(기본 2379)로 요청이 들어옵니다.
2. **속도 제한 확인:** `API Server`는 요청을 받자마자 내부의 **Client Rate Limiter** 로직을 통과시킵니다.
3. **인증/인가 확인:** Rate Limit을 통과하면, `API Server`는 요청의 보안 정보(인증 헤더 등)를 추출하여 Auth Module에 전달합니다. **Auth** Module은 etcd Store를 참조하여 사용자 권한을 검증합니다.
4. **핵심 로직으로 전달:** 모든 검증을 통과해야 비로소 요청은 Raft Protocol로 전달되어 쓰기 작업을 시작하거나, **Store (MVCC)**&#xC5D0;서 읽기 작업을 수행하게 됩니다.

{% hint style="info" %}
**Lease 체크**는 API Server가 직접 처리하는 **Auth단계의 일부**(Lease 자원에 대한 권한 확인)이거나, KV Store가 데이터를 다루기 직전에 수행하는 데이터 유효성 검사에 포함된다고 이해하시면 됩니다.&#x20;
{% endhint %}

| 검증 항목               | etcd 컴포넌트               | 필요성 (목적)                 | 상세 기능 (효과)                                                                                                                                                                                    |
| ------------------- | ----------------------- | ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Client Rate Limiter | API Server              | 안정성 (Stability) & DoS 방어 | 클라이언트의 초당 요청 횟수를 제한하여 특정 클라이언트가 etcd 서버에 과부하를 주어 서비스 거부(DoS) 상태를 유발하는 것을 방지하고, 클러스터의 처리 능력을 보호합니다.                                                                                            |
| AUTH (인증/인가)        | Auth Module             | 보안 (Security) & 데이터 보호   | <ol><li> 인증: 유효한 사용자만 etcd에 접근하도록 통제합니다. </li></ol><ol start="2"><li> 인가: 접근이 허가된 사용자라도, 각 키에 대해 설정된 권한(읽기/쓰기/삭제)을 넘어선 작업을 수행하는 것을 막아 민감한 데이터를 보호합니다.</li></ol>                               |
| LEASE (임대)          | Lease Module & KV Store | 효율성 (Efficiency) & 자원 관리 | <ol><li>클라이언트 연결이 끊어지거나 서비스에 장애가 발생했을 때, 해당 서비스가 등록한 키(예: 분산 락, 서비스 IP)가 만료되어 자동으로 삭제되도록 보장합니다. </li></ol><ol start="2"><li>불필요한 데이터가 영구히 남는 것을 막아 데이터베이스 크기를 관리하고 Deadlock을 방지합니다.</li></ol> |

#### KV Store(MVCC)

KV Store (MVCC)는 etcd의 핵심 저장 엔진으로, 키-값 저장소(Key-Value Store)의 기능을 다중 버전 동시성 제어(Multi-Version Concurrency Control) 기술로 구현한 것입니다.

{% hint style="success" %}
**KV Store와 MVCC 가 같은 건가요, 별개의 개념인가요?**

KV Store와 MVCC는 별개의 개념이 아니며, 서로 분리할 수 없는 관계에 있습니다.&#x20;

즉, etcd에서 KV Store는 곧 **MVCC 기술을 사용하여 구현된 저장소**를 의미합니다.

"두 개가 다르냐, 같은 거냐"고 물으신다면, 다음과 같이 설명할 수 있습니다.

1. **개념적으로는 다릅니다**. KV Store는 _무&#xC5C7;_&#xC744; 저장하는지, MVCC는 _어떻게_ 저장하는지에 대한 설명)
2. **etcd 구현체에서는 사실상 같은 것으로 통용**됩니다. etcd의 KV Store는 MVCC를 사용하기 때문에)
{% endhint %}

KV Store와 MVCC의 개념적 차이에 대해 먼저 알아봅시다(무엇 vs 어떻게).

| 개념       | 역할 (무엇)                                                                     | 기술 (어떻게)                                                 |
| -------- | --------------------------------------------------------------------------- | -------------------------------------------------------- |
| KV Store | 데이터를 '키-값 쌍' 형태로 저장하고 관리하는 데이터 저장소의 구조입니다.                                  | 키-값 인터페이스를 제공하는 모든 저장소를 지칭할 수 있습니다. (Redis, Memcached 등) |
| MVCC     | 데이터에 '**버전(Revision)'**&#xC744; 부여하여 동시성을 제어하고 이력 관리를 가능하게 하는 데이터베이스 기술입니다. | KV Store를 구현하는 방식 중 하나입니다.                               |

etcd에서 KV Store를 설명할 때는 뒤에 MVCC가 붙는 경우가 많습니다. 이는 etcd의 데이터 저장소가 일반적인 KV Store와 달리 다음과 같은 독특한 특징을 갖기 때문입니다.

| 일반 KV Store                            | etcd의 KV Store(MVCC)              |
| -------------------------------------- | --------------------------------- |
| 데이터를 덮어쓰거나 삭제하면 이전 값은 사라짐 (하나의 값만 존재). | 데이터를 덮어써도 이전 값이 남아있음 (여러 버전이 공존). |
| 현재 시점의 값만 알 수 있음.                      | 특정 Revision (과거 시점)의 값도 알 수 있음.   |

따라서 etcd의 KV Store는 MVCC라는 기술을 통해 구현된 특수한 KV 저장소를 의미하며, MVCC가 없이는 etcd의 핵심 기능인 Watch API와 시간 여행 쿼리가 불가능합니다.

{% hint style="info" %}
Watch API와 시간 여행 쿼리는 분산 시스템의 동적 변화를 감지하고 과거 상태를 조회하는 핵심 기능입니다.

* Watch API는 클라이언트가 etcd의 특정 키 또는 키 범위에 '**지속적인 감시(Subscription)'**&#xB97C; 설정하여, 해당 데이터에 변경 사항이 발생할 때마다 실시간으로 알림을 받는 기능입니다.
* 시간 여행 쿼리는 etcd에 현재 저장된 값이 아닌, **과거의 특정 시점(Revision)**&#xC5D0; 저장되어 있던 값을 조회하는 기능입니다. etcd의 MVCC 덕분에 이전 버전의 데이터가 보존되어 있어 가능합니다.
{% endhint %}

### 선형화 가능 읽기 (Linearizable Read)

| 단계                   | 요청 주체         | 대상 컴포넌트         | 역할 및 설명                                                                                                                              |
| -------------------- | ------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| \[1] 요청 수신 및 \[2] 검증 | Client        | API Server      | 클라이언트 요청(`GET`)을 수신하고, Auth/Lease 컴포넌트를 통해 인증 및 권한을 확인합니다.                                                                           |
| \[3-1] Raft 리더십 검증   | API Server    | Raft Protocol   | `API Server`는 `Raft Protocol`에게 **Read Index** 요청을 보냅니다. 이는 현재 노드가 여전히 유효한 Leader이며, 자신이 알고 있는 데이터가 클러스터에서 최신 상태임을 보장하기 위한 합의 검증입니다. |
| \[3-2] 인덱스 검증        | Raft Protocol | Raft 노드들        | `Leader`는 `Follower`들에게 **Heartbeat**를 보내 자신의 Term과 **Index**를 확인하고, 과반수로부터 유효함을 응답받습니다. (데이터 복제는 발생하지 않으며, 상태 검증만 이루어집니다.)          |
| \[4] 데이터 인출          | API Server    | KV Store (MVCC) | `Raft Protocol`로부터 검증 완료 응답을 받으면, `API Server`는 KV Store의 인메모리 인덱스에서 요청된 키의 최신 값을 안전하게 가져옵니다.                                        |
| \[5] 응답 전송           | API Server    | 클라이언트           | 클라이언트에게 응답을 반환합니다.                                                                                                                   |

#### Leader 검증

선형화 가능 읽기는 최신 데이터의 일관성을 위해 Leader의 검증이 필요합니다.

| 요청 받은 노드              | 동작                                                                                                                                 |
| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| **리더(Leader)인 경우**    | Raft Protocol의 **Read Index** 메커니즘을 사용하여 자신의 상태가 최신임을 검증합니다. 이 검증이 완료된 후에만 KV Store에서 데이터를 읽어옵니다.                                  |
| **팔로워(Follower)인 경우** | 클라이언트의 요청을 **Leader에게 라우팅(Forwarding)**&#xD569;니다. Leader는 Read Index 검증을 거친 후 응답을 Follower에게 돌려주고, Follower가 최종적으로 클라이언트에게 응답합니다. |

API Server의 **Raft 리더십 검증** 단계는 크게 두 가지를 의미합니다.

1. **클라이언트의 라우팅**: 클라이언트가 팔로워에게 요청을 보내면, 팔로워는 그 요청을 Leader에게 자동으로 라우팅합니다. (쓰기와 선형화 읽기 모두)
2. **Leader의 검증**: Leader는 데이터를 읽기 전에 Read Index를 사용하여 자신이 여전히 Leader이며 최신 데이터를 가지고 있는지 확인합니다.

따라서 클라이언트는 Leader가 누구인지 몰라도 되며, etcd Server 내부의 Raft 컴포넌트가 모든 일관성 및 라우팅 로직을 처리해 줍니다.

#### Read Index

Read Index는 etcd의 Raft 프로토콜 내부에서 **선형화 가능 읽기(Linearizable Read)의 일관성을 보장하기 위해 사용하는 메커니즘이**며, 이 메커니즘을 구현하는 과정에 **Heartbeat 메시지 전송**이 포함됩니다.&#x20;

| 개념         | 역할                                                                                                                                      | Heartbeat 포함 여부                                  |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| Read Index | **Linearizable Read**를 처리하기 위한 총체적인 일관성 검증 메커니즘입니다. **Leader**가 자신이 아직 **Leader**며, 읽으려는 데이터의 **Commit Index**가 유효함을 확인하는 과정 전체를 의미합니다. | Read Index를 구현하는 핵심 단계로 Heartbeat 메시지 전송을 사용합니다. |
| Heartbeat  | $$Raft$$ 노드 간에 정기적으로 전송되는 작은 메시지입니다. 주로 Leader의 생존을 알리고 Follower들이 Candidate로 전환하는 것을 막는 역할을 합니다. Read Index 과정에서는 상태 검증용으로 활용됩니다.      | Read Index 메커니즘을 작동시키는 특정 RPC(함수 호출)의 일종입니다.     |

Leader가 클라이언트로부터 **Linearizable Read** 요청을 받으면, **Read Index** 기능은 다음과 같은 순서로 실행됩니다.

1. 현재 **Commit Index** 기록: Leader는 자신이 알고 있는 가장 최신의 **커밋된 로그 인덱스(Commit Index)**&#xB97C; 로컬에 기록합니다. (이 인덱스 이하의 데이터만 안전하게 읽을 수 있음)
2. **Heartbeat** 전송 (활용): Leader는 모든 Follower에게 **Heartbeat메시지를 강제로 전송**하고 응답을 기다립니다.
3. **Quorum** 확인:Leader는 **과반수(Quorum)**&#xC758; Follower들로부터 Heartbeat 응답을 받으면, 현재 클러스터가 네트워크 분할(Split-Brain) 상태가 아니며 자신이 여전히 **유효한 Leader**임을 확인합니다.
4. 로컬 데이터 읽기: 검증이 완료되면, Leader는 로컬 KV Store에서 1단계에서 기록한 Commit Index까지 반영된 데이터를 읽어서 클라이언트에게 반환합니다.

이 전체 과정을 **Read Index** 메커니즘이라고 부르며, **Heartbeat** 메시지 전송은 Leader의 유효성을 빠르게 확인하기 위한 수단으로 사용되는 것입니다. 쓰기처럼 데이터 복제 과정은 생략하여 성능을 높이면서도 일관성을 유지합니다.



### 직렬화 가능 읽기(Serializable Read)

| 단계                   | 요청 주체      | 대상 컴포넌트         | 역할 및 설명                                                                               |
| -------------------- | ---------- | --------------- | ------------------------------------------------------------------------------------- |
| \[1] 요청 수신 및 \[2] 검증 | Client     | API Server      | 클라이언트 요청(`GET` with `Serializable` 옵션)을 수신하고, Auth/Lease 컴포넌트를 통해 인증 및 권한을 확인합니다.     |
| \[3] Raft 우회 결정      | API Server | -               | 직렬화 가능 읽기 요청이므로, Raft Protocol을 통한 합의나 검증 과정을 완전히 생략합니다.                              |
| \[4] 데이터 인출          | API Server | KV Store (MVCC) | `API Server`는 KV Store의 인메모리 인덱스에서 요청된 키의 로컬 상태 값을 즉시 가져옵니다.                          |
| \[5] 응답 전송           | API Server | 클라이언트           | 클라이언트에게 응답을 반환합니다. 이 데이터는 다른 노드에 최신 Write가 이미 커밋되었더라도 해당 노드의 상태를 반영하므로 최신이 아닐 수 있습니다. |
