---
description: 쿠버네티스의 각 구성요소가 존재하는 이유
---

# 컨트롤플레인과 노드

### 쿠버네티스 클러스터

<figure><img src="../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

‘클러스터(cluster)’는 본래 “비슷한 것들이 한데 모여 있는 집합”을 뜻합니다. IT 분야에서 클러스터는 여러 대의 컴퓨터(서버)를 하나의 시스템처럼 묶어 작업을 분산 처리하고 고가용성을 확보하는 구조를 말합니다.

쿠버네티스 문서([링크](https://kubernetes.io/ko/docs/concepts/architecture/))에서는 클러스터를 다음과 같이 정의합니다.

> 쿠버네티스 클러스터는 컨트롤 플레인과 노드라고 불리는 일련의 워커 머신으로 구성되어 있으며, 이 노드들은 컨테이너화된 애플리케이션을 실행한다. 모든 클러스터는 파드를 실행하기 위해 최소한 하나의 워커 노드가 필요하다.

즉, 쿠버네티스 클러스터는 아래와 같이 구성됩니다.

* **Control Plane(컨트롤 플레인)**: 전체 상태를 관리하고 지휘하는 두뇌 역할의 노드 집합
* **Worker Nodes(작업자 노드)**: 실제로 컨테이너화된 애플리케이션을 실행하는 서버들

컨트롤 플레인과 작업자 노드를 합친 **전체 집합**을 하나의 쿠버네티스 **클러스터**라고 부릅니다.

### 지휘자와 일꾼

쿠버네티스는 크게 두 영역으로 나뉘어 작동합니다. 컨트롤 플레인을 지휘자로, 워커 노드를 일꾼으로 볼 수 있습니다.

<figure><img src="../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

<table><thead><tr><th width="89.12890625">구분</th><th>명칭</th><th>비유</th><th>역할</th></tr></thead><tbody><tr><td>제어 영역</td><td>컨트롤 플레인 (Control Plane)</td><td>운영팀/지휘자 (시스템의 뇌)</td><td>전체 클러스터의 상태를 결정하고 관리하며, 명령을 내리는 주체</td></tr><tr><td>작업 영역</td><td>워커 노드 (Worker Node)</td><td>일꾼/작업 서버(근육)</td><td>실제로 컨테이너를 실행하고, 명령받은 작업을 수행하며, 현재 상태를 보고</td></tr></tbody></table>

각 영역에는 다시 여러 핵심 컴포넌트가 있습니다. 컨트롤 플레인부터 워커 노드의 순서로 하나씩 살펴보겠습니다.



### 컨트롤 플레인

<figure><img src="../.gitbook/assets/image (6).png" alt="" width="375"><figcaption></figcaption></figure>

컨트롤 플레인은 쿠버네티스 클러스터의 심장부이자 지능적인 제어 영역으로 전체 상태를 관리합니다.

주요 구성요소는 크게 **'kube-apiserver', 'etcd', 'kube-scheduler', 'controller manager'**&#xC758; 네가지로 나눌 수 있습니다.  각 구성 요소에 대해서는 별도의 페이지에서 자세하게 다룰테니 가볍게 읽고 넘어가도 괜찮습니다.

#### kube-apiserver

쿠버네티스 클러스터의 단일 진입점으로 모든 명령과 상태 조회가 이곳을 거치게 됩니다. 여기서 모든 명령이란 쿠버네티스 클러스터를 만들고 운영할 때 사용자가 내리는 API 요청을 뜻합니다. 즉, kubectl로 입력하거나 다른 시스템(예. CI/CD 파이프라인 또는 다른 자동화  시스템)이 쿠버네티스 API를 호출해서 리소스를 생성/조회/수정/삭제(CRUD) 할 때 전달되는 모든 요청을 말합니다.

{% hint style="info" %}
kubectl은 쿠버네티스를 조작하기 위한 공식 CLI 도구입니다. 쿠버네티스 클러스터의 API 서버와 통신해 리소스를 생성/조회/수정/삭제하는 모든 작업을 수행할 때 사용합니다.
{% endhint %}

#### etcd

클러스터의 모든 상태를 저장하는 분산 키-값 저장소입니다. 여기서 모든 상태란, 쿠버네티스가 원하는 상태(Desired State)와 현재 상태(Current State)를 비교/유지하기 위해 필요한 모든 리소스 정보를 말합니다.

예를 들어 “order-service 파드를 3개 유지하라”는 사용자의 선언(Desired State)이 저장되는 곳입니다.

{% hint style="info" %}
**파드(Pod)**&#xB294; 쿠버네티스에서 **가장 작은 배포 단위**로, **하나 이상의 컨테이너**와 그들이 공유하는 스토리지, 네트워크 설정 등을 묶어 놓은 집합입니다. 파드는 **항상 노드 위에서 실행**됩니다.
{% endhint %}

#### kube-scheduler

새로 생성된 파드를 어느 노드에 배치할지 결정합니다. CPU·메모리 요구량, 노드의 현재 부하, 어피니티/안티어피니티 규칙을 고려합니다.

예를 들어 주문 폭주로 새로운 파드가 필요할 때, Scheduler가 가장 여유 있는 노드를 골라 자동으로 파드를 띄우게 됩니다.

{% hint style="info" %}
**노드(Node)**&#xB780; **파드가 실제로 실행되는 물리 서버나 가상 머신**을 말합니다. 쿠버네티스 클러스터는 여러 노드로 이루어져 있고, 각각의 노드가 컨테이너 실행을 담당합니다.
{% endhint %}

#### controller manager

클러스터가 사용자가 선언한 **Desired State**를 유지하도록 끊임없이 감시하고 조정합니다.

예를 들어 파드 3개를 유지해야 하는데 1개가 장애로 죽었다면, ReplicaSet Controller가 즉시 새 파드를 1개 더 생성합니다. 이를 자가 치유(Self-Healing)라고 부릅니다.

{% hint style="info" %}
**Desired State**는 사용자가 **쿠버네티스 매니페스트(YAML)**&#xB85C; "**클러스터가 이런 상태를 유지해야 한다**”고 선언한 목표 상태입니다.
{% endhint %}

#### 요약

| 구성 요소                         | 문제                                                                                                            | 역할                                                                                                                                        |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| API 서버 (kube-apiserver)       | 누가, 어떤 명령을 내릴지, 그리고 그 명령을 안전하게 받을 통로가 필요                                                                      | <ul><li>쿠버네티스 클러스터의 모든 통신 창구이자 프론트 도어</li><li>사용자의 모든 요청과 클러스터 내부 구성 요소 간의 통신이 이곳을 거침</li><li>보안 및 검증 역할도 수행</li></ul>                    |
| etcd                          | 시스템의 최종 목표 상태와 현재 실제 상태를 저장할 단 하나의 신뢰할 수 있는 저장소가 필요                                                           | <ul><li>클러스터의 모든 설정 데이터와 상태 정보를 저장하는 분산 키-값 저장소</li><li>쿠버네티스 클러스터의 단 하나의 진실의 원천(Single Source of Truth) 역할</li></ul>                     |
| 컨트롤러 매니저 (Controller Manager) | &#xC0AC;_&#xC6A9;자가 원하는 상&#xD0DC;_&#xC640; _시스템의 실제 상&#xD0DC;_&#xAC00; 다를 때, 이를 자동으로 맞춰주는 자동 감시 및 복구 스크립트가 필요 | <ul><li>다양한 컨트롤러 (복제 컨트롤러, 엔드포인트 컨트롤러 등)를 실행</li></ul><ul><li><strong>'현재 상태 = 원하는 상태'</strong>가 되도록 무한 루프를 돌면서 감시하고 자동으로 수정 조치</li></ul> |
| 스케줄러 (kube-scheduler)         | 새로 실행할 컨테이너가 있을 때, **가장 적합한 서버(노드)**&#xB97C; 판단하여 배치 필요 (리소스의 효율적인 사용)                                        | <ul><li>새로 생성된 컨테이너가 실행될 최적의 워커 노드를 결정</li><li>노드의 CPU, 메모리 잔여량, 부하, 네트워크 조건 등 복잡한 요소를 고려하여 배치</li></ul>                                  |



### 노드

<figure><img src="../.gitbook/assets/image (9).png" alt="" width="375"><figcaption></figcaption></figure>

워커 노드는 실제로 사용자의 컨테이너(Pod)가 실행되는 서버입니다. 컨트롤 플레인이 내린 명령을 받아 이행하고 그 결과를 다시 보고하는 역할을 합니다.

#### kubelet

노드에서 파드가 제대로 실행되는지 주기적으로 API Server에 보고하고, 필요하면 컨테이너를 시작·중지합니다. 예를 들어 특정 노드에서 파드가 비정상 종료되면 kubelet이 이를 감지하고 Controller Manager에 알려, 새로운 파드를 다시 시작하게 합니다.

#### kube-proxy

쿠버네티스 Service 개념을 구현하기 위해 네트워크 프록시와 로드밸런싱을 담당합니다. 예를 들어 사용자가 `order-service`라는 고정된 DNS 이름으로 접속하면 kube-proxy가 동적으로 바뀌는 파드 IP를 찾아 트래픽을 분산시킵니다.

#### Container Runtime

실제 컨테이너를 실행하는 엔진(Docker, containerd 등)입니다. 예를 들어 `order-service` 파드를 시작하라는 명령이 오면 kubelet이 container runtime에게 컨테이너를 띄우라고 지시합니다.



#### 요약

| 구성 요소                  | 해결하려던 문제 / 존재하는 이유                                                         | 역할 설명                                                                                                                                |
| ---------------------- | -------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| Kubelet                | 명령을 내리는 컨트롤 플레인과 실제로 컨테이너를 실행하는 서버 간의 통신 및 조정이 필요                          | <ul><li>각 워커 노드에서 실행되는 에이전트</li><li>API 서버로부터 받은 명령(예: "이 서버에 컨테이너를 띄워라")을 컨테이너 런타임(Docker 등)에 전달하고, 실행 상태를 다시 컨트롤 플레인에 보고</li></ul> |
| Kube Proxy             | 컨테이너들이 동적으로 생성/파괴되어도, 사용자가 변하지 않는 주소로 서비스에 접속할 수 있어야 함 (서비스 디스커버리 및 로드밸런싱) | <ul><li>쿠버네티스 서비스 네트워킹을 관리</li><li>서비스 요청이 들어오면, 자동으로 해당 서비스를 제공하는 컨테이너들로 트래픽을 분산하고 연결</li></ul>                                     |
| CRI(Container Runtime) | 실제로 컨테이너 이미지를 다운받고 격리된 환경에서 실행시켜야 함                                        | <ul><li>컨테이너의 실행을 담당합니다. (예: Docker, containerd, CRI-O 등)</li></ul>                                                                  |



