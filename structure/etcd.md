# etcd

etcd는 쿠버네티스 클러스터의 **모든 상태**를 저장하는 **분산 키-값 저장소**입니다.

### 상태 의미

쿠버네티스에서 **상태(State)**&#xB294; 단순히 pod가 'Running'인지 아닌지 같은 런타임 정보만을 뜻하지 않습니다. 클러스터를 구성하고 동작시키는 모든 오브젝트의 스펙(spec)과 현재 상황이 포함됩니다.

### etcd가 보관하는 주요 상태 범주

| etcd가 보관하는 주요 상태 범주 | 구체적 예시(오브젝트)                                                             | 설명                                                      |
| ------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------- |
| **워크로드 리소스**        | Pods, Deployments, ReplicaSets, StatefulSets, DaemonSets, Jobs, CronJobs | 어떤 애플리케이션을 몇 개의 인스턴스로, 어떤 설정으로 실행해야 하는지                 |
| **서비스 및 네트워크**      | Services, Endpoints, Ingress, NetworkPolicy                              | 서비스 이름과 IP 매핑, 로드밸런싱 규칙, 네트워크 통신 정책                     |
| **구성/비밀 관리**        | ConfigMaps, Secrets                                                      | 앱이 사용할 설정 값, 민감한 데이터(비밀번호, API 키 등)                     |
| **스토리지 관련**         | PersistentVolume(PV), PersistentVolumeClaim(PVC), StorageClass           | 상태 저장 서비스가 사용하는 볼륨 및 스토리지 정책                            |
| **보안/권한**           | ServiceAccounts, Roles, RoleBindings, ClusterRoles                       | 인증/인가 설정, RBAC(Role-Based Access Control) 정책            |
| **클러스터 메타데이터**      | Nodes, Namespaces, ResourceQuotas, LimitRanges                           | 노드 등록 정보, 네임스페이스 단위의 리소스 제한                             |
| **상태(Status) 정보**   | 각 리소스의 현재 상태 필드 (`status` section)                                       | 파드의 현재 Phase(Running, Pending), 노드의 Ready 여부 등 현재 동작 상황 |

### **오브젝트 의미**

**오브젝트(Object)**&#xB294; 쿠버네티스가 관리해야 하는 실제 리소스를 표현하는 단위입니다. 클러스터 안에서 '무엇을 만들고 유지할지'를 나타내는 기록이라고 볼 수 있습니다. &#x20;

오브젝트 안에 있는 원하는 상태(Desired State)를 기술하는 부분을 **스펙(spec)**&#xC774;라고 부릅니다. 사용자가 '이 오브젝트가 이렇게 동작해야 한다'라고 선언적으로 적어두는 설정입니다.

### 주요 오브젝트 종류

| 오브젝트                                     | 설명                         |
| ---------------------------------------- | -------------------------- |
| Pod                                      | 컨테이너 실행 단위                 |
| Service                                  | 파드를 묶어 네트워크로 접근 가능하게 하는 단위 |
| Deployment                               | 파드의 수, 업데이트 전략 등을 관리하는 단위  |
| ConfigMap / Secre                        | 설정 값이나 비밀 정보 저장            |
| PersistentVolume / PersistentVolumeClaim | 스토리지 볼륨과 그 사용 요청           |
| Namespace                                | 리소스를 구분하는 논리적 영역           |

### ETCD를 사용하는 이유

#### 1. 단일 진실 저장소 (Single Source of Truth)

쿠버네티스는 수많은 컴포넌트(API Server, Scheduler, Controller Manager, kubelet 등)가 동시에 같은 데이터를 읽고 써야 합니다. 이때 **어느 컴포넌트가 봐도 동일한, 신뢰할 수 있는 단일 데이터 원본**이 필요합니다.

etcd는 Raft 합의 알고리즘을 사용해 **모든 노드에 동일한 데이터를 복제**하고, 어느 노드에서 읽더라도 항상 일관된 데이터를 보장합니다.

{% hint style="info" %}
**Raft 합의(Consensus) 알고리즘**은 여러 대의 컴퓨터(노드)가 네트워크로 묶인 **분산 시스템**에서 모두가 **동일한 데이터 값을 신뢰할 수 있도록 합의(Consensus)를 이루는 방법**입니다. 쿠버네티스의 etcd가 이 알고리즘을 사용해 “클러스터 상태”를 안전하게 저장하고 복제합니다.

합의가 왜 필요할까요? 예를 들어봅시다. 분산 시스템에서는 데이터가 여러 노드에 복제되어 있습니다. 하지만 **네트워크 단절, 노드 장애, 메시지 지연** 같은 문제가 항상 발생할 수 있습니다. 이때 모든 노드가 서로 다른 값을 저장한다면, 진짜 데이터가 무엇인지를 결정할 방법이 필요하고, 이 문제를 합의 문제라고 부릅니다.
{% endhint %}

#### 2. Desired State와 Current State를 비교·유지하기 위해

쿠버네티스의 핵심 아이디어는 “원하는 상태(Desired State)를 선언하면, 컨트롤러가 실제 상태(Current State)를 그에 맞추어 유지한다”입니다.

* 사용자가 Deployment 매니페스트로 `replicas: 3`을 선언하면 이 정보가 etcd에 기록됩니다.
* Controller Manager는 etcd에 기록된 **spec**(원하는 상태)과 kubelet이 보고하는 **status**(현재 상태)를 비교합니다.
* 차이가 있으면 Scheduler·kubelet 등을 통해 새 파드를 띄우거나 장애 노드에서 파드를 다른 노드로 옮겨 원하는 상태를 맞춥니다.

즉, etcd가 **Desired/Current 상태를 모두 보관하는 단일 데이터베이스**이기 때문에 컨트롤 플레인이 이 차이를 실시간으로 감지하고 조정할 수 있습니다.

#### 3. 고가용성(HA)과 내결함성(FT)

쿠버네티스 클러스터는 수백, 수천 개의 노드에서 운영될 수 있고 부분 장애가 일상적으로 발생할 수 있습니다.\
etcd는 Raft 합의 알고리즘을 통해 **다중 노드에 상태를 복제**하여 한 노드가 다운되더라도 데이터가 유실되지 않게 합니다.

이 특성 덕분에 쿠버네티스는 **컨트롤 플레인의 장애 복구**나 **클러스터 재시작** 시에도 원하는 상태를 잃지 않고, 운영을 이어갈 수 있습니다.

{% hint style="info" %}
**고가용성(High Availability, HA)** 은 시스템이나 서비스가 장애나 유지보수 같은 상황에서도 **장시간 중단 없이 지속적으로 사용 가능한 상태를 유지하는 능력**을 말합니다.
{% endhint %}

{% hint style="info" %}
**내결함성(Fault Tolerance)** 은 시스템의 일부 구성 요소가 **고장(Fault)** 나더라도 전체 서비스가 중단되지 않고 **정상적으로 동작을 계속할 수 있는 능력**을 말합니다.
{% endhint %}

#### 4. 트랜잭션과 변경 이력

etcd는 **원자적 트랜잭션**과 **변경 이력(revision history)** 기능을 제공합니다.&#x20;

{% hint style="info" %}
**원자적 트랜잭션**은 데이터베이스에서 한 번의 작업 단위(트랜잭션) 안의 모든 연산이 **모두 성공하거나, 아예 아무 것도 적용되지 않도록** 보장하는 성질을 말합니다.

* **데이터 일관성 유지**: 중간 단계에서 일부만 적용되면 데이터가 꼬일 수 있습니다.
* **장애 복구**: 작업 도중 네트워크가 끊기거나 노드가 고장 나도, 트랜잭션 전체가 취소되면 시스템이 안전한 상태를 유지할 수 있습니다.
* **분산 환경 안정성**: etcd나 쿠버네티스처럼 여러 노드가 동시에 데이터를 쓰는 환경에서, “반쯤 기록된 값”이 남지 않게 보장합니다.

etcd는 Raft 합의 알고리즘을 사용해 키-값 변경을 트랜잭션 단위로 커밋합니다. 파드 스케일링을 3→5로 늘리는 도중 일부 노드에만 반영되고 다른 노드가 실패한다면, 클러스터 전체 상태가 뒤죽박죽될 수 있습니다. 원자적 트랜잭션이 이를 방지해 “모두 성공” 혹은 “모두 실패”로 일관성을 보장합니다.
{% endhint %}

Controller나 API Server는 특정 리비전 이후의 변화만 감지해 효율적으로 동작할 수 있습니다. 또한 watch 기능을 통해 **변경 이벤트를 실시간으로 구독**할 수 있어, 컨트롤러들이 즉각적으로 반응할 수 있습니다.

{% hint style="info" %}
변경이력은 분산 키-값 저장소(etcd 등)에서 각 데이터 변경 시점마다 **리비전(Revision) 번호**를 부여하고,\
과거의 변경 기록을 조회하거나, 특정 시점 이후의 변화만 추적할 수 있게 하는 기능입니다.

* **이벤트 구독(Watches)**: 컨트롤러가 “이 리비전 이후의 변경만” 실시간으로 감지해 빠르게 반응할 수 있습니다.
* **롤백·디버깅**: 과거 상태를 재현하거나, 어떤 변경이 장애를 유발했는지 추적할 수 있습니다.
* **동시성 제어**: 클라이언트가 특정 리비전을 기준으로 조건부 업데이트를 수행해 경쟁 상태(race condition)를 방지할 수 있습니다.
{% endhint %}

